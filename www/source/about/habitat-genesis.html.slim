---
title: Genesis
---

h1 The Genesis of Habitat

p Chef is an automation company. Ever since it was founded in 2008, we've been
  bringing together developers and system administrators with our namesake
  product, Chef. The result is an enormous ecosystem of tools and integrations,
  as well as a large community that believes in the same thing that we do:
  automation products should address multiple domains and provide a holistic
  view of the environment. Consequently, any company that uses Chef can
  accelerate their velocity and deliver their own digital products quickly and
  reliably.

p Over the years, what we mean by automation has evolved, and its scope has
  widened. We've seen Chef transform from a configuration management platform
  into a complete automation workflow that takes you all the way from
  development to production. That workflow includes development tools,
  infrastructure automation, application deployment, and compliance. Along the
  way, it also gives you visibility into the whole process. This evolution
  happened because we worked closely with customers to solve their most
  pressing automation problems, saw the shortcomings in their existing tools
  and processes, and wrote software to fill the gap. We've also spent a lot of
  time observing and anticipating trends in the business world. Our goals are
  to understand what companies are trying to accomplish, as seen through the
  lens of software, and to fix what's blocking them.

p Companies today have an extensive digital presence, backed by numerous custom
  applications that differentiate them from their competitors. Over time, those
  applications have grown in complexity as has the burden of managing them.
  The applications need infrastructure, they need to be monitored, they need to
  share data, and they are actually often a collection of interconnected
  services rather than a single, monolithic component. This trend toward
  increasingly sophisticated application topologies with complex dependency
  relationships shows no signs of slowing down. It's the source of the
  complexity crisis in modern application management.

h2 The complexity crisis in modern application management

p The crisis in management tooling is the result of the way application
  development has occurred over the last generation. Instead of starting with
  business value and planning the features that will make products stand out,
  we've been letting the infrastructure stack that supports the code dictate
  the design of the application. What hardware will we use? What OS will we
  use? What application frameworks will we use? Should we use a PaaS? What
  should we do for service discovery? How will we handle runtime configuration
  management? What about secrets? The list goes on and on. These are concerns
  that application developers end up having to solve&mdash;and bind their
  application tightly to&mdash;even before they write any significant business
  logic. The end result is that businesses have a huge proliferation of
  applications and application stacks that are totally heterogeneous, thereby
  creating an infrastructure management nightmare.

p Fundamentally, we have a design problem. If all the business value is in the
  application, why do we design for infrastructure first? The approach of
  beginning at the bottom of the stack and working our way up to eventually
  reach the application is backwards. Further, it leads to command-and-control
  automation with complex nonlocal behavior and global side effects.

p Instead, we should first define what it means for a modern application to be
  well behaved and then work down towards the infrastructure. If you take this
  approach, you get an infrastructure that is quite small because many things
  end up being under the control of the application itself. The application can
  control how it should respond to dynamic changes in its environment by
  policy, how it should behave when deployed under different topologies, and
  even how it should control its dependencies. In other words, you get Habitat.

h2 Enter Habitat

p Habitat is a new open-source project created by Chef and spearheaded by its
  co-founder and CTO Adam Jacob. Habitat tackles the problem of complexity and
  automation-by-side-effect head on by packaging the automation along with the
  application. In other words, Habitat is <em>automation that travels with the
  app</em>.  Any application, whether greenfield or legacy, that is wrapped in
  a Habitat package, has the intelligence to be aware of its own environment
  and to react to changes in that environment. Habitat allows the application
  to be independent of any particular infrastructure environment, such as
  containers or PaaS, and to present a well-defined interface to the outside
  world that makes commonplace tasks such as monitoring easy to do.

p Habitat speaks directly to the problem of complexity <em>and</em>
  high-velocity development. It handles the management tasks that deflect teams
  from focusing on actually developing new products and features. It frees
  legacy applications from being tied to a particular environment, and makes
  them portable and simpler to manage. This new breed of application isn't just
  deployed or managed in an automated way. A Habitat application can
  self-organize, self-configure, and act autonomously.

p To achieve this goal, Habitat provides a packaging format and a runtime
  supervisor. Any application that is wrapped as a Habitat package is atomic,
  immutable and auditable. Â At runtime, the Habitat supervisor configures and
  manages the application for whatever environment is present.

p The Habitat ecosystem also provides a build service. The build service takes
  a Habitat-format build plan, creates the Habitat artifact, and publishes it
  to a depot.

p Habitat is designed for modern application teams that are multi-disciplinary
  and collaborative. The Habitat plan describes not only how to build the
  application package but also defines its behavior in real-life deployment
  scenarios that are human-readable and can be stored in a version control
  system such as Git. They are also simple to write. The application's
  automation API&mdash;also defined in the plan&mdash;presents a clear
  interface for release engineering that makes it easy for different team
  members to define the areas that concern them most, such as monitoring or
  performance tuning.

p Habitat packages can run, unmodified, across a wide variety of runtime
  environments, from bare metal and virtual machines all the way to containers
  such as Docker, grid systems such as Mesosphere or Kubernetes, or even PaaS
  systems such as Pivotal Cloud Foundry. Independence from the environment is
  important because it lets application developers defer choices about the
  infrastructure until very late in the development cycle, rather than making
  them early on and letting them dictate the design of the application.

h2 Get started today

p Are you ready to solve your company's complexity crisis? Do you want to spend
  your time creating great new features that will make your applications
  delight your customers, rather than having to solve basic runtime and
  infrastructure problems over and over again? Do you want to imbue legacy
  applications with modern application characteristics without having to
  rewrite them from scratch? If you are, get started with Habitat.  Check out
  the #{link_to 'documentation', '/docs/index.html'} and
  #{link_to 'tutorials', '/tutorials/index.html'}. The tutorials will get you
  up and running quickly.  Habitat is an open source project, and your
  suggestions and contributions are incredibly important. You can find the
  GitHub repo #{link_to 'here', 'https://github.com/habitat-sh/habitat'}. Join
  us!

<hr>
<ul class="main-content--button-nav">
  <li><a href="/about/what-is-modern-app" class="button cta">Next - What is a Modern Application?</a></li>
</ul>
