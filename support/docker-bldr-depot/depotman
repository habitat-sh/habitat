#!/bin/sh

# # Internals

set -eu

if [ -n "${DEBUG:-}" ]; then
  set -x
fi


# ## Help/Usage functions

print_help() {
  printf -- "$program

The Bldr Maintainers <bldr@chef.io>

Bldr Depot Docker Machine Manager

USAGE:
        $program [COMMON_FLAGS] <SUBCOMMAND> [ARG ..]

        $program launch [NAME]
        $program create-machine [MACHINE_NAME]
        $program load-image [TARBALL]
        $program deploy-service [SERVICE_NAME]
        $program kill-service [SERVICE_NAME]
        $program destroy-machine [MACHINE_NAME]

        $program logs [SERVICE_NAME]
        $program repo-url [MACHINE_NAME] [SERVICE_NAME]

        $program export-config [MACHINE_NAME]
        $program import-config <CONFIG_TARFILE>

COMMON FLAGS:
    -h  Prints this message

SUBCOMMANDS:
    create-machine    Creates a Docker Machine instance
    deploy-service    Deploys a Bldr Depot service
    destroy-machine   Destroys a Docker Machine instance
    export-config     Exports a shareable Docker Machine configuration
    kill-service      Kills a Bldr Depot service
    launch            Creates a Docker Machine and deploys a Bldr Depot service
    load-image        Loads the Bldr image into Docker instance
    logs              Streams the Bldr Depot logs
    repo-url          Prints the BLDR_REPO URL
    help              Prints this message

ENVIRONMENT VARIABLES:
    AWS_ACCESS_KEY_ID     (Required) AWS access key id
    AWS_SECRET_ACCESS_KEY (Required) AWS secret access key
    AWS_DEFAULT_REGION    Overrides default AWS region (default: us-west-2)
    AWS_VPC_ID            (Required) AWS VPC id
    DOCKER_MACHINE_NAME   Overrides default machine name (default: bldrdepot)
    MACHINE_STORAGE_PATH  Overrides default (default: ~/.docker/machine/machines)

"
}


# ## Subcommand functions

subcommand_create_machine() {
  # Ensure we have required environment variables
  : ${AWS_ACCESS_KEY_ID}
  : ${AWS_SECRET_ACCESS_KEY}
  : ${AWS_VPC_ID}
  : ${USER}

  local machine="${1:-${DOCKER_MACHINE_NAME:-bldrdepot}}"
  local region="${AWS_DEFAULT_REGION:-us-west-2}"
  local vpc="$AWS_VPC_ID"
  local security_group="${AWS_SECURITY_GROUP:-docker-ephemeral-ports}"

  info "Creating EC2 Docker Machine: $machine"

  if docker-machine ls -q | grep -q "^$machine$"; then
    exit_with "Docker Machine $machine already exists. Destroy and continue?" 3
  fi

  docker-machine create -d amazonec2 \
    --amazonec2-vpc-id $vpc \
    --amazonec2-region $region \
    --amazonec2-security-group $security_group \
    --amazonec2-instance-type m3.medium \
    --amazonec2-tags "X-Project,bldr,X-Created-By,$USER" \
    $machine
}

subcommand_destroy_machine() {
  local machine="${1:-${DOCKER_MACHINE_NAME:-bldrdepot}}"
  load_machine $machine

  info "Destroying EC2 Docker Machine: $machine"

  docker-machine stop $machine || true
  docker-machine rm -f $machine
}

subcommand_export_config() {
  local machine="${1:-${DOCKER_MACHINE_NAME:-bldrdepot}}"
  load_machine $machine

  local src="$(docker-machine inspect \
    -f '{{.HostOptions.AuthOptions.StorePath}}' $machine)"

  local tarfile="docker-machine-$machine-$(date -u +%Y-%m-%d-%H%M%S)-config.tar"

  local dir="$(mktemp -d ${TMPDIR:-/tmp}/docker-machine-config-XXXXXX)"
  trap 'echo "Cleaning up $dir"; rm -rf $dir; exit $?' INT TERM EXIT

  cp -rv $src $dir/

  docker-machine inspect $machine | sed \
    -e "s|$HOME|@HOME@|g" \
    -e 's|"AccessKey": "[^"]*",|"AccessKey": "@ACCESS_KEY@",|g' \
    -e 's|"SecretKey": "[^"]*",|"SecretKey": "@SECRET_KEY@",|g' \
    > $dir/$machine/config.json

  info "Saving Docker Machine configuration for $machine to $tarfile"

  tar -c -C $dir -f $tarfile $machine

  rm -rf $dir
  trap - INT TERM EXIT
}

subcommand_import_config() {
  # Ensure we have required environment variables
  : ${AWS_ACCESS_KEY_ID}
  : ${AWS_SECRET_ACCESS_KEY}

  local tarfile="$1"
  local machine="$(dirname $(tar tf $tarfile bldrdepot | grep config.json))"
  local storage_path="${MACHINE_STORAGE_PATH:-$HOME/.docker/machine/machines}"

  if docker-machine ls -q | grep -q "^$machine$"; then
    exit_with "Docker Machine $machine already exists. Move and continue?" 3
  fi

  info "Importing Docker Machine configuration for $machine from $tarfile"

  mkdir -pv $storage_path
  trap 'rm -rfv $storage_path/$machine; exit $?' INT TERM EXIT

  tar xvf $tarfile -C $storage_path
  sed \
    -e "s|@HOME@|$HOME|g" \
    -e "s|@ACCESS_KEY@|$AWS_ACCESS_KEY_ID|g" \
    -e "s|@SECRET_KEY@|$AWS_SECRET_ACCESS_KEY|g" \
    $storage_path/$machine/config.json > $storage_path/$machine/config.json.new
  mv -v $storage_path/$machine/config.json.new $storage_path/$machine/config.json
  chmod 0600 $storage_path/$machine/config.json

  if ! docker-machine ls -q | grep -q "^$machine$"; then
    exit_with "Docker Machine $machine could not be loaded; aborting" 8
  fi

  info "Docker Machine $machine loaded."
  docker-machine ls

  trap - INT TERM EXIT
}

subcommand_kill_service() {
  local project="${1:-bldrdepot}"
  load_machine

  info "Killing Bldr Depot service $project"

  docker-compose -p $project stop
  docker-compose -p $project rm -f -v
}

subcommand_launch() {
  if [ ! -f "$image_tar" ]; then
    exit_with "Docker image $image tarball $image_tar does not exist; aborting" 6
  fi

  subcommand_create_machine $*
  subcommand_load_image
  subcommand_deploy_service $*
}

subcommand_load_image() {
  local image_tar="${1:-$image_tar}"
  load_machine

  if [ ! -f "$image_tar" ]; then
    exit_with "Docker image $image tarball $image_tar does not exist; aborting" 6
  fi

  info "Loading $image image into Docker instance from $image_tar"

  docker load -i $image_tar
}

subcommand_logs() {
  local project="${1:-bldrdepot}"
  load_machine

  exec docker-compose -p $project logs
}

subcommand_deploy_service() {
  local project="${1:-bldrdepot}"
  load_machine

  if [ -z "$(docker images -q $image)" ]; then
    exit_with "Docker image $image must be loaded, use '$program load-image'" 5
  fi

  info "Deploying Bldr Depot service $project"

  docker-compose -p $project up -d
}

subcommand_repo_url() {
  local machine="${1:-${DOCKER_MACHINE_NAME:-bldrdepot}}"
  local project="${2:-bldrdepot}"
  QUIET=true load_machine $machine

  local ip="$(docker-machine ip $machine)"
  local port="$(docker-compose -p $project port app 9632 | awk -F: '{print $2}')"

  echo "http://${ip}:${port}"
}


# ## Private/Internal helper functions

info() {
  if [ -n "${QUIET:-}" ]; then
    return 0
  fi

  case "${TERM:-}" in
    *term | xterm-* | rxvt | screen | screen-*)
      printf -- "   \033[1;36m${program:-unknown}: \033[1;37m$1\033[0m\n"
      ;;
    *)
      printf -- "   ${program:-unknown}: $1\n"
      ;;
  esac
  return 0
}

exit_with() {
  case "${TERM:-}" in
    *term | xterm-* | rxvt | screen | screen-*)
      printf -- "\033[1;31mERROR: \033[1;37m$1\033[0m\n"
      ;;
    *)
      printf -- "ERROR: $1\n"
      ;;
  esac
  exit $2
}

find_system_commands() {
  if ! command -v docker-machine > /dev/null; then
    exit_with "We require docker-machine to manage the node; aborting" 1
  fi
  if ! command -v docker-compose > /dev/null; then
    exit_with "We require docker-compose to manage the service; aborting" 1
  fi
  if ! command -v docker > /dev/null; then
    exit_with "We require docker to load the image; aborting" 1
  fi
}

load_machine() {
  local machine="${1:-${DOCKER_MACHINE_NAME:-bldrdepot}}"

  if ! docker-machine ls -q | grep -q "^$machine$"; then
    exit_with "Docker Machine $machine does not exist; aborting" 4
  fi

  # Load Docker Machine environment, unless we already have
  if [ -z "$machine_loaded" ]; then
    info "Loading Docker Machine environment for: $machine"
    eval "$(docker-machine env $machine)"
    machine_loaded=true
  fi
}


# # Main Flow

find_system_commands

# ## Default variables

# The short version of the program name which is used in logging output
program=$(basename $0)
#
image="bldr/base:latest"
#
image_tar="bldr-base-latest.tar"
#
machine_loaded=


# ## CLI Argument Parsing

while getopts ":h" opt; do
  case $opt in
    h)
      print_help
      exit 0
      ;;
    \?)
      print_help
      exit_with "Invalid option: -$OPTARG" 1
      ;;
  esac
done
shift "$((OPTIND - 1))"

case ${1:-} in
  c|cr|cre|crea|creat|create|create-machine)
    shift
    subcommand_create_machine $*
    ;;
  dep|depl|deplo|deploy|deploy-service)
    shift
    subcommand_deploy_service $*
    ;;
  des|dest|destr|destro|destroy|destroy-machine)
    shift
    subcommand_destroy_machine $*
    ;;
  e|ex|exp|expo|expor|export|export-config)
    shift
    subcommand_export_config $*
    ;;
  h|he|hel|help)
    print_help
    exit 0
    ;;
  i|im|imp|impo|impor|import|import-config)
    shift
    subcommand_import_config $*
    ;;
  k|ki|kil|kill|kill-service)
    shift
    subcommand_kill_service $*
    ;;
  la|lau|laun|launc|launch)
    shift
    subcommand_launch $*
    ;;
  loa|load|load-image)
    shift
    subcommand_load_image $*
    ;;
  log|logs)
    shift
    subcommand_logs $*
    ;;
  r|re|rep|repo|repo-url)
    shift
    subcommand_repo_url $*
    ;;
  *)
    print_help
    exit_with "Invalid argument: ${1:-}" 1
    ;;
esac
