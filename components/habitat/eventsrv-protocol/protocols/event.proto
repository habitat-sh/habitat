syntax = "proto2";

/// Messages sent to an EventSrv from a Habitat Supervisor.
package habitat.eventsrv;

/// The base for all messages generated by an EventSrv. This message contains framing
/// to hint to a consumer how to encode/decode the message's payload and information for
/// how to route or index the message.
message EventEnvelope {
  /// Enumerator of potential encoding types for the Envelope's payload
  enum Type {
    /// Encoded with a Google Protobuf
    ProtoBuf = 1;
    /// Encoded with JSON
    JSON = 2;
    /// Encoded with TOML
    TOML = 3;
  }

  /// Message payload hint to a decoder
  optional Type type = 1;
  /// Contents of message
  optional bytes payload = 2;
  /// Time of message origination in milliseconds since the Epoch (1970-01-01T00:00:00Z).
  optional uint64 timestamp = 3;
  /// Member-ID of originating Supervisor
  optional string member_id = 4;
  /// Service name of originating Supervisor service
  optional string service = 5;
  /// Supervisor's incarnation at message origination
  optional uint64 incarnation = 6;
  /// Message's sequence ID
  optional uint64 sequence_id = 7;
}

/// System information generated by the Supervisor of the machine it is running on.
message SysInfo {
  /// Public facing IP address of Supervisor
  optional string ip = 1;
  /// Network hostname of Supervisor
  optional string hostname = 2;
  /// Listening address for Supervisor's gossip connection
  optional string gossip_ip = 3;
  /// Listening port for Supervisor's gossip connection
  optional string gossip_port = 4;
  /// Listening address for Supervisor's http gateway
  optional string http_gateway_ip = 5;
  /// Listening port for Supervisor's http gateway
  optional string http_gateway_port = 6;
}

/// Information describing the package a service is running.
message PackageIdent {
  /// Origin name of package
  optional string origin = 1;
  /// Software name of package
  optional string name = 2;
  /// Software version of package
  optional string version = 3;
  /// Build release timestamp of package
  optional string release = 4;
}

/// Generated by service and census information from Supervisors representing a single service group.
message ServiceUpdate {
  /// Member-ID of originating Supervisor
  optional string member_id = 1;

  /// Service name
  optional string service = 2;
  /// Service group name
  optional string group = 3;
  /// Service group organization name
  optional string org = 4;
  // NOTE: service group application and environment are further down
  // in this file.

  /// Gossiped configuration of service
  optional bytes cfg = 5;
  /// System information of Supervisor
  optional SysInfo sys = 6;
  /// Package information of service
  optional PackageIdent pkg = 7;
  /// `true` if the service has successfully initialized
  optional bool initialized = 8;
  /// Builder that is checked for updates
  optional string bldr_url = 9;
  /// Chennel chat is checked for updates
  optional string channel = 10;
  /// Persistent or transient
  optional string start_style = 11;
  /// Topology used by the service
  optional string topology = 12;
  /// Update strategy used by the service
  optional string update_strategy = 13;
  /// Service group application name
  optional string application = 14;
  /// Service group environment name
  optional string environment = 15;
  /// `true` if this service instance is the leader when in a leader topology
  optional bool leader = 16;
  /// `true` if this service instance is a follower when in a leader topology
  optional bool follower = 17;
  /// `true` if this service instance is the update leader when in a coordinated update topology
  optional bool update_leader = 18;
  /// `true` if this service instance is an update leader when in a coordinated update topology
  optional bool update_follower = 19;
  /// `true` if this service instance is part of a topology and an election is currently under way
  optional bool election_is_running = 20;
  /// `true` if this service instance is part of a topology and an election is currently under way
  /// but has come to a stop because a quorum cannot be met
  optional bool election_is_no_quorum = 21;
  /// `true` if this service instance is part of a topology and an election is finished
  optional bool election_is_finished = 22;
  /// `true` if this service instance is part of an update topology and an election is currently
  /// under way
  optional bool update_election_is_running = 23;
  /// `true` if this service instance is part of an update topology and an election is currently
  /// under way but has come to a stop because a quorum cannot be met
  optional bool update_election_is_no_quorum = 24;
  /// `true` if this service instance is part of an update topology and an election is finished
  optional bool update_election_is_finished = 25;
 }
